// ISC License
//
// Copyright (c) 2017, Milen Radkov <milenradkov@me.com>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST
//


/*
 * **DICAE** is a betting game ran on top of Aeternity blockchain,
 * this particilar implementation is done with Sophia ML
 * 
 * The game allows a player to place a bet on certain number
 * between 1 and 6 once in a betting session.
 * When the betting session is closed and bet results are calculated
 * the players who correctly guessed the number that the dice smart contract
 * rolled will receive AE tokens distributed as winning award. Funds from
 * bets of those players who did not succeeded guessing the correct
 * dice result will be stored in the smart contract for future
 * award distribution payments. 
 */
contract Dicae =

    record state = { sessions: map(int, session)
                   , bet_price: int
                   , bet_id: int
                   , bet_winning_coeficient: int
                   , session_id: int
                   , players: map(address, player)
                   , system: system }
    
    record bet = { id: int
                 , number: int
                 , player_address: address }

    record session = { session_id: int
                     , block_id: int
                     , bets: list(bet)
                     , calculated: bool }

    record player = { total_bets: int
                    , pending_balance: int }

    record system = { null_bytes: bytes(32)
                    , valid_bets: map(int, int) }
    
    stateful entrypoint init() : state = { bet_id = 0
                                      , session_id = 0
                                      , bet_price = 1
                                      , bet_winning_coeficient = 5
                                      , sessions = {[0] = {session_id = 0, block_id = Chain.block_height -1,  bets = [], calculated = false}}
                                      , players = {}
                                      , system = { null_bytes = #000000000000000000000000000000000000000000000000000000000000000
                                                 , valid_bets = { [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6 } } }

    stateful entrypoint bet(number: int) =
        is_bet_valid(number)
        reset_session_if_needed()
        is_amount_enough()
        is_player()
        let bet = { id = state.bet_id +1
                  , number = number
                  , player_address = Call.caller }
        put(state{ bet_id = bet.id
                 , sessions[state.session_id].bets = bet :: state.sessions[state.session_id].bets
                 , players[Call.caller].total_bets = state.players[Call.caller].total_bets + 1 })

    entrypoint get_random() : int = random()

    stateful entrypoint withdraw() =
        is_player_balance_positive()
        let balance_for_withdraw = state.players[Call.caller].pending_balance
        put(state{
            players[Call.caller].pending_balance = 0 })
        Chain.spend(Call.caller, balance_for_withdraw)

    // PRIVATE FUNCTIONS AND ACCESS MODIFIERS
    
    private stateful function calculate_session_results() = 
        map_function(filter_winning(random()), state.sessions[state.session_id].bets)

    private stateful function filter_winning(random_winning_number: int) : (bet => bool) = (bet) =>
        if (bet.number == random_winning_number)
            put(state{
                players[bet.player_address].pending_balance = state.players[bet.player_address].pending_balance + (state.bet_price * state.bet_winning_coeficient) })
        (bet.number == random_winning_number)

    private function map_function(f : 'a => 'b, l : list('a)) : list('b) =
        switch(l)
            [] => []
            e :: l' => f(e) :: map_function(f, l')	

    private function random() : int = 
        Bytes.to_int(Crypto.sha3(random_hash(5, state.system.null_bytes))) mod 6

    private function random_hash(blocks: int, result: bytes(32)) : bytes(32) =
        switch(blocks)
            0 => result
            _ => random_hash(blocks - 1, Crypto.sha3(String.concat(Bytes.to_str(result), Bytes.to_str(eval(Chain.block_hash(Chain.block_height - blocks))))))
        
    private function eval(x: option(bytes(32))) : bytes(32) =
        switch(x)
            None => state.system.null_bytes
            Some(x) => x

    private stateful function reset_session() =
        calculate_session_results()
        put(state{ session_id = state.session_id + 1})

    private stateful function reset_session_if_needed() =
        if (Chain.block_height >= state.sessions[state.session_id].block_id + 5)
            reset_session()

    private stateful function is_player() =
        let player_found = Map.lookup_default(Call.origin, state.players, {total_bets = 0, pending_balance = 0})
        if (player_found.total_bets == 0)
            put(state{ players[Call.origin] = {total_bets = 0, pending_balance = 0} })

    private function is_amount_enough() =
        require(Call.value < state.bet_price, "INSUFFICIENT_VALUE_PROVIDED")
    
    private function is_player_balance_positive() =
        require(state.players[Call.caller].pending_balance > 0, "INSUFFICIENT_BALANCE")
    
    private function is_bet_valid(number: int) =
        require(Map.member(number, state.system.valid_bets), "INVALID_BET_NUMBER")
