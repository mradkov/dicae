'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.execFile = exports.exec = undefined;
exports.promisifyChildProcess = promisifyChildProcess;
exports.spawn = spawn;
exports.fork = fork;

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function joinChunks(chunks, encoding) {
  if (chunks[0] instanceof Buffer) {
    var buffer = Buffer.concat(chunks);
    if (encoding) return buffer.toString(encoding);
    return buffer;
  }
  return chunks.join('');
}

function promisifyChildProcess(child) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _promise = new Promise(function (resolve, reject) {
    var stdoutChunks = [];
    var stderrChunks = [];
    if (child.stdout) child.stdout.on('data', function (data) {
      return stdoutChunks.push(data);
    });
    if (child.stderr) child.stderr.on('data', function (data) {
      return stderrChunks.push(data);
    });

    child.on('error', reject);
    function done(code, signal) {
      var error = void 0;
      if (code != null && code !== 0) error = new Error('Process exited with code ' + code);else if (signal != null) error = new Error('Process was killed with ' + signal);
      var output = {};
      if (child.stdout) output.stdout = joinChunks(stdoutChunks, options.encoding);
      if (child.stderr) output.stderr = joinChunks(stderrChunks, options.encoding);
      if (error) {
        if (code != null) error.code = code;
        if (signal != null) error.signal = signal;
        if (output.stdout) error.stdout = output.stdout;
        if (output.stderr) error.stderr = output.stderr;
        reject(error);
      } else {
        resolve(output);
      }
    }
    child.on('close', done);
    child.on('exit', done);
  });
  return Object.create(child, {
    then: { value: _promise.then.bind(_promise) },
    catch: { value: _promise.catch.bind(_promise) }
  });
}

function spawn(command, args, options) {
  return promisifyChildProcess(_child_process2.default.spawn(command, args, options), Array.isArray(args) ? options : args);
}

function fork(module, args, options) {
  return promisifyChildProcess(_child_process2.default.fork(module, args, options), Array.isArray(args) ? options : args);
}

function promisifyExecMethod(method) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var child = void 0;
    var _promise = new Promise(function (resolve, reject) {
      child = method.apply(undefined, args.concat([function (err, stdout, stderr) {
        if (err) {
          err.stdout = stdout;
          err.stderr = stderr;
          reject(err);
        } else {
          resolve({ stdout: stdout, stderr: stderr });
        }
      }]));
    });
    if (!child) throw new Error("unexpected error: child has not been initialized");
    return Object.create(child, {
      then: { value: _promise.then.bind(_promise) },
      catch: { value: _promise.catch.bind(_promise) }
    });
  };
}

var exec = exports.exec = promisifyExecMethod(_child_process2.default.exec);

var execFile = exports.execFile = promisifyExecMethod(_child_process2.default.execFile);