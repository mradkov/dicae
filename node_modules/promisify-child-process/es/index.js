
import child_process from 'child_process';

function joinChunks(chunks, encoding) {
  if (chunks[0] instanceof Buffer) {
    const buffer = Buffer.concat(chunks);
    if (encoding) return buffer.toString(encoding);
    return buffer;
  }
  return chunks.join('');
}

export function promisifyChildProcess(child, options = {}) {
  const _promise = new Promise((resolve, reject) => {
    const stdoutChunks = [];
    const stderrChunks = [];
    if (child.stdout) child.stdout.on('data', data => stdoutChunks.push(data));
    if (child.stderr) child.stderr.on('data', data => stderrChunks.push(data));

    child.on('error', reject);
    function done(code, signal) {
      let error;
      if (code != null && code !== 0) error = new Error(`Process exited with code ${code}`);else if (signal != null) error = new Error(`Process was killed with ${signal}`);
      const output = {};
      if (child.stdout) output.stdout = joinChunks(stdoutChunks, options.encoding);
      if (child.stderr) output.stderr = joinChunks(stderrChunks, options.encoding);
      if (error) {
        if (code != null) error.code = code;
        if (signal != null) error.signal = signal;
        if (output.stdout) error.stdout = output.stdout;
        if (output.stderr) error.stderr = output.stderr;
        reject(error);
      } else {
        resolve(output);
      }
    }
    child.on('close', done);
    child.on('exit', done);
  });
  return Object.create(child, {
    then: { value: _promise.then.bind(_promise) },
    catch: { value: _promise.catch.bind(_promise) }
  });
}

export function spawn(command, args, options) {
  return promisifyChildProcess(child_process.spawn(command, args, options), Array.isArray(args) ? options : args);
}

export function fork(module, args, options) {
  return promisifyChildProcess(child_process.fork(module, args, options), Array.isArray(args) ? options : args);
}

function promisifyExecMethod(method) {
  return (...args) => {
    let child;
    const _promise = new Promise((resolve, reject) => {
      child = method(...args, (err, stdout, stderr) => {
        if (err) {
          err.stdout = stdout;
          err.stderr = stderr;
          reject(err);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
    if (!child) throw new Error("unexpected error: child has not been initialized");
    return Object.create(child, {
      then: { value: _promise.then.bind(_promise) },
      catch: { value: _promise.catch.bind(_promise) }
    });
  };
}

export const exec = promisifyExecMethod(child_process.exec);

export const execFile = promisifyExecMethod(child_process.execFile);